Convertir aplicaciones de escritorio en aplicaciones móviles con Java

I. Introducción
Después de programar en la plataforma J2SE uno de los caminos a seguir es dejar los ambientes para computadores de escritorio y portátiles e ingresar a los ambientes de dispositivos móviles. Al día de hoy, las aplicaciones deben adaptarse a los diferentes dispositivos que se encuentran en el mercado, con mayor razón si estos dispositivos tienen una alta difu-sión en personas cuya relación con la tecnología es mínima o en algunos casos nula. Esta ventaja debe aprovecharse con rapidez y eficiencia para reescribir de forma ágil y correcta aplicaciones de éxito des-de entornos de escritorio o portátiles a entornos de dispositivos móviles. JavaFX es uno de los últimos len-guajes lanzados por Sun Microsystems (Javafx 2009) que une sus anteriores productos J2ME, Java 2D y fortalece las RIA (Rich Internet Aplications) para ob-tener beneficios en diseño con efectos visuales den-tro de la lógica requerida (Javafx.com, 2009). Aquí Sun vuelve a apostar por su premisa ‘write once – run everywhere’, tema de artículos (Portal.acm, 2009) donde se presentan la conversión de aplicaciones J2SE a aplicaciones J2ME. El lenguaje J2ME (Develo-pers 2009) difiere del lenguaje JavaFX por el paradig-ma que ambos utilizan, los dos pueden implementar el mismo, orientado a objetos pero JavaFX tiene la flexibilidad de incluir la implementación de los para-digmas para los lenguajes script (Frt.utn, 2009).

Las necesidades de conversión de una plataforma a otra, en este caso de escritorio a móvil, pueden resu-mirse (Burigat.Chittaro, 2007) desde la presentación de datos y navegación entre ellos; por ejemplo en móviles, los usuarios son forzados a realizar tareas de acercamiento-alejamiento para obtener una visión global de la información con altas posibilidades de desorientación y aumento de complejidad, pasan-do por la velocidad en el cálculo de instrucciones, de este modo, en escritorio, se tienen equipos con alta capacidad de procesamiento y almacena-miento para representar gráficos 3D o mapas deta-llados de posición geográfica, hasta llegar a perifé-ricos específicos de trabajo. Esto influye en el diseño de aplicaciones, los paradigmas de programación deben adaptarse a las necesidades y característi-cas de su entorno, por ejemplo, la generación de menús en teléfonos celulares puede realizarse en-tre los modelos (Amant.Horton.Ritter, 2007) Fitts’ law, GOMS o ACT-R que permiten un patrón de calidad para medir comportamiento, niveles de detalle y análisis en los usuarios.

Este artículo presenta una guía para convertir apli-caciones de escritorio en aplicaciones móviles con Java, mediante pasos ordenados, así como un lista-do de apuntes sobre buenas prácticas al momento de la implementación sobre JavaFX. Así, se descri-be al inicio los antecedentes, que actualmente se encuentran sobre el tema, para luego explicitar la metodología del proceso de conversión y exponer finalmente los resultados.

II. Antecedentes
Las aplicaciones móviles deben estar en capacidad de manejar características como trabajo desconec-tado y utilización adecuada de los recursos, en arqui-tecturas de componentes que puedan correr sobre diferentes capas (Nori, 2007). Se busca entonces, que su desarrollo tenga en cuenta: baja carga de archivos en compilación, eficiencia en invocaciones, baja redundancia de datos, acceso directo a la in-formación, incluyendo programación por compo-nentes, interfaces gráficas simples y ágiles, recargas puntuales de datos, código exacto. Estas caracterís-ticas a hoy se evidencian, siendo reconocidas como requerimientos no funcionales sobre plataformas mó-viles, por lo tanto al ir de una plataforma de escritorio, la nueva aplicación móvil, debe reflejarlas en el pro-ceso de conversión. Aparecen también, los lengua-jes scripts que permiten naturalidad y flexibilidad en la programación, resultando una transición del paradig-ma de programación orientado a objetos. Sin embar-go, los trabajos de investigación consultados hacen referencia (Turunen, 2005) a cambios en aplicaciones ya realizadas, que se modifican para aumentar su al-cance en portabilidad u otros requerimientos adicio-nales, por ejemplo, una aplicación móvil inicial que aplica posteriormente otra arquitectura para manejar diálogos multimodales distribuidos.

Una de las principales razones para tomar una aplicación de escritorio ya existente y convertirla a una aplicación móvil, es la rapidez con la cual debe liberarse el código para evitar que el tiempo de vida útil de los dispositivos móviles las convierta en obsoletas y sean necesarias adecuaciones sin ser liberadas aún (Balan, 2007). Adicionalmente, se comparte en este artículo la posición de cambio parcial, del artículo anteriormente mencionado; no es necesario modificar todo el código original para obtener el código sobre el dispositivo móvil, pero no se comparte la idea de una plataforma neutral de desarrollo. Aquí se presenta una serie de pasos ordenados para convertir el desarrollo inicial, como forma manual y aproximación inicial de procesos más complejos, en los cuales si debiese automati-zarse el resultado final, conclusiones que entrega el artículo consultado. En la metodología, resultados y conclusiones, del presente artículo, se entregarán preguntas puntuales a responder que indican las características a encontrarse en la aplicación de escritorio para obtener su equivalencia en la aplicación móvil, así como la recurrencia a la experiencia del programador en el desarrollo e implementación de patrones, permitiendo los cambios apropiados, sin perder los objetivos primarios del proceso, fide-lidad en los resultados, en el ¿qué de aplicación?, entregando la libertad en “el ¿cómo hace la apli-cación?” que depende en un alto porcentaje de las características de la plataforma en que se ejecute. Como se mencionaba al inicio, dichas característi-cas forman una política de ejecución, asegurando que si se cumple permita la ejecución y conversión de la aplicación, también se conoce con el nom-bre de política de adaptación (Balan, 2007), que son definidas, adecuadas e implementadas.

III. Metodología
Se tomó como aplicación ejemplo, un juego lla-mado “El Aprendiz”, desarrollado en J2SE versión 1.6 update 14 (Java.sun, 2009) para definir y concluir los cambios que una aplicación en esa plataforma contemplaría para acercarse a la promesa de Sun. El Aprendiz es un juego cuyo objetivo es completar satisfactoriamente, ejercitando la memoria, una ruta aleatoria de luces. Se puede seleccionar el nivel de dificultad que depende del número de luces que componen la ruta y del tiempo de visualización de cada luz ante el usuario para recordarlas. El usuario pierde al momento en que la ruta de luces ingresa-da no es correcta, el usuario puede reiniciar el juego cada vez que lo desee. El juego interactúa con el jugador y almacena al finalizar, el nivel, el tiempo in-vertido y el nombre del ganador para mantener una tabla de posiciones con los 5 mejores jugadores en tiempo. La aplicación tiene la presentación gráfica de las figuras 1 a la 3, esta visualización no cambió entre un lenguaje y otro:

Al programar en J2SE se aplicaron las buenas prácti-cas del diseño orientado a objetos (Faculty, 2009) pre-sentes en los patrones de software (quienes capturan las mejores soluciones para problemas que se presen-tan repetidamente) manteniendo la reutilización, ex-tensibilidad, bajo acoplamiento y alta cohesión (Web. cs, 2009). Algunos de los más representativos son los GRASP, patrones de asignación de responsabilidades (General Responsibility Assignment Software Patterns), entre ellos, patrón creador, patrón controlador, patrón experto y patrón fachada (Cs.wcupa, 2009). JavaFX actualmente tiene libertad de implementar las solu-ciones desde la óptica orientada a objetos o desde la óptica script, la pregunta que definió el camino fue de la mano de la principal fortaleza que promete Ja-vaFX, el diseño gráfico, si la aplicación tiene un alto número de pantallas y una navegación compleja la respuesta es aplicar diseño orientado a objetos, si por el contrario la aplicación tiene un alto número de animaciones pero bajo número de pantallas y nave-gación de complejidad simple puede optar por el modelo script. Sin embargo, en este punto aunque la respuesta parecía obvia lo más recomendado fue considerar una mezcla equilibrada de los dos para-digmas en el diseño de la aplicación JavaFX ya sea nueva o en migración de una aplicación J2SE. La aplicación El Aprendiz tomó esta decisión.

La siguiente pregunta consideró la permanencia del mismo diseño de clases y relaciones de la aplicación J2SE en la nueva aplicación JavaFX?, Para este caso, la respuesta fue no. Los patrones de software que se aplicaron en el diseño se centraron en solucionar problemas que llegaron de los requerimientos fun-cionales y no funcionales, pero para JavaFX la lista de requerimientos funcionales se ve opacada por la lista de requerimientos no funcionales donde la apli-cación se torna más exigente, específica y mínima. Los requerimientos no funcionales tienen que ver con características que de una u otra forma puedan li-mitar el sistema, como por ejemplo, desempeño, disponibilidad, escalabilidad, usabilidad, flexibilidad, instalación, mantenibilidad, operatividad, seguridad, integración, conectividad.

Las aplicaciones JavaFX sobre dispositivos móviles se diseñan teniendo como prioridad los requerimientos no funcionales de desempeño, usabilidad, persisten-cia y conectividad, aunque existen patrones que ha-cen referencia a estos requerimientos, se debe con-centrar la atención en las condiciones de memoria y espacio, particionando las aplicaciones en clases que permitan intercambiar su manejo en memoria, implementando un diseño separado de lógica, dis-minuir el nombre de los atributos, métodos y clases para disminuir el tamaño de la aplicación binaria.

IV. Resultados
Adicional a las condiciones de memoria y espacio presentes en los dispositivos móviles, fue necesario poner especial cuidado en el diseño gráfico, en la reproducción de sonido, video, manejo de tama-ños y navegación, convirtiendo esta preocupación en otro punto a favor de la respuesta negativa a la pregunta anterior. Hay una diferencia entre los APIs de las dos plataformas que componen la parte grá-fica, por ejemplo, JavaFX (Java, 2009) no considera necesarias las clases de Security Manager, RMI, Cor-ba, las clases que manejan la interfaz gráfica varían desde la pareja SWING-AWT en J2SE hasta la línea principal de visualización de JavaFX formada por las clases Stage, Scene y Content que se visualizan en la figura 5.

El borde de la gráfica representa la ventana (Stage), dentro se encuentra el espacio de trabajo (Scene) donde se ubican en forma jerárquica los objetos grá-ficos. Los objetos gráficos propios de una aplicación y diferentes a los presentes en el API gráfico de JavaFX son creados por herencia de la clase CustomNode que permite personalizar e incluir las características y comportamientos propios exigidos. Así mismo, la aplicación en J2SE puede trabajar con un tamaño fijo sin importar las dimensiones de la pantalla donde se ejecute, situación que no es cómoda de adoptar en los dispositivos móviles, las aplicaciones deben adecuar su visualización a la variedad de tamaños y funcionalidades presentes, este cambio entre apli-caciones se evidencia más en la implementación que en la etapa de diseño.

Así pues, las aplicaciones realizadas sobre J2SE no tienen que preocuparse en su gran mayoría por el espacio de procesamiento, la velocidad de lec-tura o el manejo de recursos pues se presentan como ilimitados por toda la facilidad y velocidad con que aumentan dentro de la infraestructura de los computadores de escritorio y portátiles que se ofrecen de fácil actualización. Otro requerimiento no funcional es la conectividad, los computadores de escritorios cuentan siempre con acceso a Inter-net, pero los dispositivos móviles como los teléfo-nos celulares, por su naturaleza, están en constante búsqueda de conexión. El juego no utilizó dichas características por lo que el artículo sólo lo mencio-na por su relevancia.
	
La persistencia sobre base de datos es algo común en las aplicaciones J2SE de la cual se conocen y se han implementado patrones y soluciones para mejo-rar desempeño. En los dispositivos móviles el espacio es un recurso crítico y el uso de base de datos puede implementarse en otros tipos de aplicaciones para dispositivos móviles como son cliente-servidor o con-sumo de servicios WEB que no son el alcance de este artículo. En cuanto al desarrollo local que convirtió El Aprendiz de lenguaje J2SE a lenguaje JavaFX usan-do archivos textos como persistencia, que debieron convertirse en recursos de almacenamiento (espa-cios de memoria identificados con un nombre cual-quiera) permitiendo el manejo del espacio principal y secundario en los dispositivos móviles.

El empleo de las aplicaciones en J2SE está repre-sentado en el manejo del ratón y el teclado como periféricos de entrada, sin embargo, en las aplica-ciones JavaFX (Javapassion, 2009) sobre dispositivos móviles el ingreso de información se realiza con las teclas de navegación arriba, abajo, izquierda, de-recha, confirmar, aceptar y rechazar estas pueden simularse desde una aplicación J2SE con las flechas de posicionamiento presentes en el teclado de los computadores de escritorio y portátiles, esto garan-tiza que una pantalla táctil recibirá sin mayores con-tratiempos una aplicación realizada pensando en un dispositivo móvil de pantalla estándar.

Las preguntas y puntos mencionados anteriormente se aplicaron para pasar de J2SE a JavaFX, siguién-dolos esta guía presenta el diagrama de clases del ejemplo El Aprendiz para JavaFX en la figura 6.

En la implementación y las pruebas, JavaFX disminu-yó los tiempos, aplicando las ventajas de los lengua-jes script programando con instrucciones básicas, fáciles de entender, naturales, en el juego durante la implementación en J2SE se invirtieron 24 horas y para JavaFX 16 horas aproximadamente.

V. Conclusiones
Las ventanas emergentes que presentan datos de confirmación deben cambiarse a visualizaciones de escenas diferentes dentro del escenario que si-mulan el comportamiento de las anteriores.

Los dispositivos móviles utilizan una máquina vir-tual KVM llamada así por la referencia a pocos kilobytes de tamaño, demostrando que JavaFX se enfoca en ciertos APIs específicos porque no requiere de los otros, por lo tanto una buena prác-tica de programación es importar sólo las clases exactas dentro de los paquetes en la aplicación para evitar cargas de código que no sean nece-sarias en la ejecución.

Una ventaja que tiene Java en sus plataformas es el Garbage Collector que permite concentrar es-fuerzos en la lógica, no en la administración de los recursos permitiendo liberar en forma desatendida el espacio en memoria.

En la etapa de pruebas las aplicaciones JavaFX necesitan de un emulador genérico de dispositi-vo móvil o del propio del teléfono para realizar sus pruebas, mientras que las aplicaciones de escrito-rio no.  La flexibilidad de las pruebas llega en seleccionar el dispositivo móvil más acorde a las características de la aplica-ción, por ejemplo que tenga pantalla táctil o que posea teclado QWERTY.

Sin importar el diseño implementado en la aplicación J2SE, si se utilizó MVC o se presentan patrones de diseño para mane-jo de recursos, es posible pasar la aplica-ción a JavaFX conservando la integridad y lógica independiente del análisis, diseño e implementación original.

